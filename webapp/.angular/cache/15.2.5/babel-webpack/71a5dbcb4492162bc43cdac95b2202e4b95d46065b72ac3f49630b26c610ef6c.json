{"ast":null,"code":"import _asyncToGenerator from \"/home/andrew/Dropbox/school/408/group_project/src/webapp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { property } from 'lit/decorators.js';\nimport { CanvasTexture, RepeatWrapping, sRGBEncoding, VideoTexture } from 'three';\nimport { GLTFExporter } from 'three/examples/jsm/exporters/GLTFExporter.js';\nimport { $needsRender, $onModelLoad, $progressTracker, $renderer, $scene } from '../model-viewer-base.js';\nimport GLTFExporterMaterialsVariantsExtension from '../three-components/gltf-instance/VariantMaterialExporterPlugin';\nimport { $availableVariants, $materialFromPoint, $prepareVariantsForExport, $switchVariant, Model } from './scene-graph/model.js';\nimport { Texture as ModelViewerTexture } from './scene-graph/texture';\nexport const $currentGLTF = Symbol('currentGLTF');\nexport const $originalGltfJson = Symbol('originalGltfJson');\nexport const $model = Symbol('model');\nconst $getOnUpdateMethod = Symbol('getOnUpdateMethod');\nconst $buildTexture = Symbol('buildTexture');\n/**\n * SceneGraphMixin manages exposes a model API in order to support operations on\n * the <model-viewer> scene graph.\n */\nexport const SceneGraphMixin = ModelViewerElement => {\n  var _a, _b, _c;\n  class SceneGraphModelViewerElement extends ModelViewerElement {\n    constructor() {\n      super(...arguments);\n      this[_a] = undefined;\n      this[_b] = null;\n      this[_c] = null;\n      this.variantName = null;\n      this.orientation = '0 0 0';\n      this.scale = '1 1 1';\n    }\n    // Scene-graph API:\n    /** @export */\n    get model() {\n      return this[$model];\n    }\n    get availableVariants() {\n      return this.model ? this.model[$availableVariants]() : [];\n    }\n    /**\n     * Returns a deep copy of the gltf JSON as loaded. It will not reflect\n     * changes to the scene-graph, nor will editing it have any effect.\n     */\n    get originalGltfJson() {\n      return this[$originalGltfJson];\n    }\n    [(_a = $model, _b = $currentGLTF, _c = $originalGltfJson, $getOnUpdateMethod)]() {\n      return () => {\n        this[$needsRender]();\n      };\n    }\n    [$buildTexture](texture) {\n      // Applies glTF default settings.\n      texture.encoding = sRGBEncoding;\n      texture.wrapS = RepeatWrapping;\n      texture.wrapT = RepeatWrapping;\n      return new ModelViewerTexture(this[$getOnUpdateMethod](), texture);\n    }\n    createTexture(uri, type = 'image/png') {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        const {\n          textureUtils\n        } = _this[$renderer];\n        const texture = yield textureUtils.loadImage(uri);\n        texture.userData.mimeType = type;\n        return _this[$buildTexture](texture);\n      })();\n    }\n    createLottieTexture(uri, quality = 1) {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        const {\n          textureUtils\n        } = _this2[$renderer];\n        const texture = yield textureUtils.loadLottie(uri, quality);\n        return _this2[$buildTexture](texture);\n      })();\n    }\n    createVideoTexture(uri) {\n      const video = document.createElement('video');\n      video.src = uri;\n      video.muted = true;\n      video.playsInline = true;\n      video.loop = true;\n      video.play();\n      const texture = new VideoTexture(video);\n      return this[$buildTexture](texture);\n    }\n    createCanvasTexture() {\n      const canvas = document.createElement('canvas');\n      const texture = new CanvasTexture(canvas);\n      return this[$buildTexture](texture);\n    }\n    updated(changedProperties) {\n      var _superprop_getUpdated = () => super.updated,\n        _this3 = this;\n      return _asyncToGenerator(function* () {\n        _superprop_getUpdated().call(_this3, changedProperties);\n        if (changedProperties.has('variantName')) {\n          const updateVariantProgress = _this3[$progressTracker].beginActivity();\n          updateVariantProgress(0.1);\n          const model = _this3[$model];\n          const {\n            variantName\n          } = _this3;\n          if (model != null) {\n            yield model[$switchVariant](variantName);\n            _this3[$needsRender]();\n            _this3.dispatchEvent(new CustomEvent('variant-applied'));\n          }\n          updateVariantProgress(1.0);\n        }\n        if (changedProperties.has('orientation') || changedProperties.has('scale')) {\n          if (!_this3.loaded) {\n            return;\n          }\n          const scene = _this3[$scene];\n          scene.applyTransform();\n          scene.updateBoundingBox();\n          scene.updateShadow();\n          _this3[$renderer].arRenderer.onUpdateScene();\n          _this3[$needsRender]();\n        }\n      })();\n    }\n    [$onModelLoad]() {\n      super[$onModelLoad]();\n      const {\n        currentGLTF\n      } = this[$scene];\n      if (currentGLTF != null) {\n        const {\n          correlatedSceneGraph\n        } = currentGLTF;\n        if (correlatedSceneGraph != null && currentGLTF !== this[$currentGLTF]) {\n          this[$model] = new Model(correlatedSceneGraph, this[$getOnUpdateMethod]());\n          this[$originalGltfJson] = JSON.parse(JSON.stringify(correlatedSceneGraph.gltf));\n        }\n        // KHR_materials_variants extension spec:\n        // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_variants\n        if ('variants' in currentGLTF.userData) {\n          this.requestUpdate('variantName');\n        }\n      }\n      this[$currentGLTF] = currentGLTF;\n    }\n    /** @export */\n    exportScene(options) {\n      var _this4 = this;\n      return _asyncToGenerator(function* () {\n        const scene = _this4[$scene];\n        return new Promise( /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* (resolve, reject) {\n            // Defaults\n            const opts = {\n              binary: true,\n              onlyVisible: true,\n              maxTextureSize: Infinity,\n              includeCustomExtensions: false,\n              forceIndices: false\n            };\n            Object.assign(opts, options);\n            // Not configurable\n            opts.animations = scene.animations;\n            opts.truncateDrawRange = true;\n            const shadow = scene.shadow;\n            let visible = false;\n            // Remove shadow from export\n            if (shadow != null) {\n              visible = shadow.visible;\n              shadow.visible = false;\n            }\n            yield _this4[$model][$prepareVariantsForExport]();\n            const exporter = new GLTFExporter().register(writer => new GLTFExporterMaterialsVariantsExtension(writer));\n            exporter.parse(scene.model, gltf => {\n              return resolve(new Blob([opts.binary ? gltf : JSON.stringify(gltf)], {\n                type: opts.binary ? 'application/octet-stream' : 'application/json'\n              }));\n            }, () => {\n              return reject('glTF export failed');\n            }, opts);\n            if (shadow != null) {\n              shadow.visible = visible;\n            }\n          });\n          return function (_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }());\n      })();\n    }\n    materialFromPoint(pixelX, pixelY) {\n      const model = this[$model];\n      if (model == null) {\n        return null;\n      }\n      const scene = this[$scene];\n      const ndcCoords = scene.getNDC(pixelX, pixelY);\n      const hit = scene.hitFromPoint(ndcCoords);\n      if (hit == null || hit.face == null) {\n        return null;\n      }\n      return model[$materialFromPoint](hit);\n    }\n  }\n  __decorate([property({\n    type: String,\n    attribute: 'variant-name'\n  })], SceneGraphModelViewerElement.prototype, \"variantName\", void 0);\n  __decorate([property({\n    type: String,\n    attribute: 'orientation'\n  })], SceneGraphModelViewerElement.prototype, \"orientation\", void 0);\n  __decorate([property({\n    type: String,\n    attribute: 'scale'\n  })], SceneGraphModelViewerElement.prototype, \"scale\", void 0);\n  return SceneGraphModelViewerElement;\n};\n//# sourceMappingURL=scene-graph.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}