{"ast":null,"code":"import _asyncToGenerator from \"/home/andrew/Dropbox/school/408/group_project/src/webapp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { property } from 'lit/decorators.js';\nimport { USDZExporter } from 'three/examples/jsm/exporters/USDZExporter.js';\nimport { IS_AR_QUICKLOOK_CANDIDATE, IS_SCENEVIEWER_CANDIDATE, IS_WEBXR_AR_CANDIDATE } from '../constants.js';\nimport { $needsRender, $progressTracker, $renderer, $scene, $shouldAttemptPreload, $updateSource } from '../model-viewer-base.js';\nimport { enumerationDeserializer } from '../styles/deserializers.js';\nimport { ARStatus, ARTracking } from '../three-components/ARRenderer.js';\nimport { waitForEvent } from '../utilities.js';\nlet isWebXRBlocked = false;\nlet isSceneViewerBlocked = false;\nconst noArViewerSigil = '#model-viewer-no-ar-fallback';\nconst deserializeARModes = enumerationDeserializer(['quick-look', 'scene-viewer', 'webxr', 'none']);\nconst DEFAULT_AR_MODES = 'webxr scene-viewer quick-look';\nconst ARMode = {\n  QUICK_LOOK: 'quick-look',\n  SCENE_VIEWER: 'scene-viewer',\n  WEBXR: 'webxr',\n  NONE: 'none'\n};\nconst $arButtonContainer = Symbol('arButtonContainer');\nconst $enterARWithWebXR = Symbol('enterARWithWebXR');\nexport const $openSceneViewer = Symbol('openSceneViewer');\nexport const $openIOSARQuickLook = Symbol('openIOSARQuickLook');\nconst $canActivateAR = Symbol('canActivateAR');\nconst $arMode = Symbol('arMode');\nconst $arModes = Symbol('arModes');\nconst $arAnchor = Symbol('arAnchor');\nconst $preload = Symbol('preload');\nconst $onARButtonContainerClick = Symbol('onARButtonContainerClick');\nconst $onARStatus = Symbol('onARStatus');\nconst $onARTracking = Symbol('onARTracking');\nconst $onARTap = Symbol('onARTap');\nconst $selectARMode = Symbol('selectARMode');\nconst $triggerLoad = Symbol('triggerLoad');\nexport const ARMixin = ModelViewerElement => {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n  class ARModelViewerElement extends ModelViewerElement {\n    constructor() {\n      super(...arguments);\n      this.ar = false;\n      this.arScale = 'auto';\n      this.arPlacement = 'floor';\n      this.arModes = DEFAULT_AR_MODES;\n      this.iosSrc = null;\n      this.xrEnvironment = false;\n      this[_a] = false;\n      // TODO: Add this to the shadow root as part of this mixin's\n      // implementation:\n      this[_b] = this.shadowRoot.querySelector('.ar-button');\n      this[_c] = document.createElement('a');\n      this[_d] = new Set();\n      this[_e] = ARMode.NONE;\n      this[_f] = false;\n      this[_g] = event => {\n        event.preventDefault();\n        this.activateAR();\n      };\n      this[_h] = ({\n        status\n      }) => {\n        if (status === ARStatus.NOT_PRESENTING || this[$renderer].arRenderer.presentedScene === this[$scene]) {\n          this.setAttribute('ar-status', status);\n          this.dispatchEvent(new CustomEvent('ar-status', {\n            detail: {\n              status\n            }\n          }));\n          if (status === ARStatus.NOT_PRESENTING) {\n            this.removeAttribute('ar-tracking');\n          } else if (status === ARStatus.SESSION_STARTED) {\n            this.setAttribute('ar-tracking', ARTracking.TRACKING);\n          }\n        }\n      };\n      this[_j] = ({\n        status\n      }) => {\n        this.setAttribute('ar-tracking', status);\n        this.dispatchEvent(new CustomEvent('ar-tracking', {\n          detail: {\n            status\n          }\n        }));\n      };\n      this[_k] = event => {\n        if (event.data == '_apple_ar_quicklook_button_tapped') {\n          this.dispatchEvent(new CustomEvent('quick-look-button-tapped'));\n        }\n      };\n    }\n    get canActivateAR() {\n      return this[$arMode] !== ARMode.NONE;\n    }\n    connectedCallback() {\n      super.connectedCallback();\n      this[$renderer].arRenderer.addEventListener('status', this[$onARStatus]);\n      this.setAttribute('ar-status', ARStatus.NOT_PRESENTING);\n      this[$renderer].arRenderer.addEventListener('tracking', this[$onARTracking]);\n      this[$arAnchor].addEventListener('message', this[$onARTap]);\n    }\n    disconnectedCallback() {\n      super.disconnectedCallback();\n      this[$renderer].arRenderer.removeEventListener('status', this[$onARStatus]);\n      this[$renderer].arRenderer.removeEventListener('tracking', this[$onARTracking]);\n      this[$arAnchor].removeEventListener('message', this[$onARTap]);\n    }\n    update(changedProperties) {\n      super.update(changedProperties);\n      if (changedProperties.has('arScale')) {\n        this[$scene].canScale = this.arScale !== 'fixed';\n      }\n      if (changedProperties.has('arPlacement')) {\n        this[$scene].updateShadow();\n        this[$needsRender]();\n      }\n      if (changedProperties.has('arModes')) {\n        this[$arModes] = deserializeARModes(this.arModes);\n      }\n      if (changedProperties.has('ar') || changedProperties.has('arModes') || changedProperties.has('src') || changedProperties.has('iosSrc')) {\n        this[$selectARMode]();\n      }\n    }\n    /**\n     * Activates AR. Note that for any mode that is not WebXR-based, this\n     * method most likely has to be called synchronous from a user\n     * interaction handler. Otherwise, attempts to activate modes that\n     * require user interaction will most likely be ignored.\n     */\n    activateAR() {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        switch (_this[$arMode]) {\n          case ARMode.QUICK_LOOK:\n            _this[$openIOSARQuickLook]();\n            break;\n          case ARMode.WEBXR:\n            yield _this[$enterARWithWebXR]();\n            break;\n          case ARMode.SCENE_VIEWER:\n            _this[$openSceneViewer]();\n            break;\n          default:\n            console.warn('No AR Mode can be activated. This is probably due to missing \\\nconfiguration or device capabilities');\n            break;\n        }\n      })();\n    }\n    [(_a = $canActivateAR, _b = $arButtonContainer, _c = $arAnchor, _d = $arModes, _e = $arMode, _f = $preload, _g = $onARButtonContainerClick, _h = $onARStatus, _j = $onARTracking, _k = $onARTap, $selectARMode)]() {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        let arMode = ARMode.NONE;\n        if (_this2.ar) {\n          if (_this2.src != null) {\n            for (const value of _this2[$arModes]) {\n              if (value === 'webxr' && IS_WEBXR_AR_CANDIDATE && !isWebXRBlocked && (yield _this2[$renderer].arRenderer.supportsPresentation())) {\n                arMode = ARMode.WEBXR;\n                break;\n              }\n              if (value === 'scene-viewer' && IS_SCENEVIEWER_CANDIDATE && !isSceneViewerBlocked) {\n                arMode = ARMode.SCENE_VIEWER;\n                break;\n              }\n              if (value === 'quick-look' && IS_AR_QUICKLOOK_CANDIDATE) {\n                arMode = ARMode.QUICK_LOOK;\n                break;\n              }\n            }\n          }\n          // The presence of ios-src overrides the absence of quick-look\n          // ar-mode.\n          if (arMode === ARMode.NONE && _this2.iosSrc != null && IS_AR_QUICKLOOK_CANDIDATE) {\n            arMode = ARMode.QUICK_LOOK;\n          }\n        }\n        if (arMode !== ARMode.NONE) {\n          _this2[$arButtonContainer].classList.add('enabled');\n          _this2[$arButtonContainer].addEventListener('click', _this2[$onARButtonContainerClick]);\n        } else if (_this2[$arButtonContainer].classList.contains('enabled')) {\n          _this2[$arButtonContainer].removeEventListener('click', _this2[$onARButtonContainerClick]);\n          _this2[$arButtonContainer].classList.remove('enabled');\n          // If AR went from working to not, notify the element.\n          const status = ARStatus.FAILED;\n          _this2.setAttribute('ar-status', status);\n          _this2.dispatchEvent(new CustomEvent('ar-status', {\n            detail: {\n              status\n            }\n          }));\n        }\n        _this2[$arMode] = arMode;\n      })();\n    }\n    [$enterARWithWebXR]() {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        console.log('Attempting to present in AR with WebXR...');\n        yield _this3[$triggerLoad]();\n        try {\n          _this3[$arButtonContainer].removeEventListener('click', _this3[$onARButtonContainerClick]);\n          const {\n            arRenderer\n          } = _this3[$renderer];\n          arRenderer.placeOnWall = _this3.arPlacement === 'wall';\n          yield arRenderer.present(_this3[$scene], _this3.xrEnvironment);\n        } catch (error) {\n          console.warn('Error while trying to present in AR with WebXR');\n          console.error(error);\n          yield _this3[$renderer].arRenderer.stopPresenting();\n          isWebXRBlocked = true;\n          console.warn('Falling back to next ar-mode');\n          yield _this3[$selectARMode]();\n          _this3.activateAR();\n        } finally {\n          _this3[$selectARMode]();\n        }\n      })();\n    }\n    [$triggerLoad]() {\n      var _this4 = this;\n      return _asyncToGenerator(function* () {\n        if (!_this4.loaded) {\n          _this4[$preload] = true;\n          _this4[$updateSource]();\n          yield waitForEvent(_this4, 'load');\n          _this4[$preload] = false;\n        }\n      })();\n    }\n    [$shouldAttemptPreload]() {\n      return super[$shouldAttemptPreload]() || this[$preload];\n    }\n    /**\n     * Takes a URL and a title string, and attempts to launch Scene Viewer on\n     * the current device.\n     */\n    [$openSceneViewer]() {\n      const location = self.location.toString();\n      const locationUrl = new URL(location);\n      const modelUrl = new URL(this.src, location);\n      if (modelUrl.hash) modelUrl.hash = '';\n      const params = new URLSearchParams(modelUrl.search);\n      locationUrl.hash = noArViewerSigil;\n      // modelUrl can contain title/link/sound etc.\n      params.set('mode', 'ar_preferred');\n      if (!params.has('disable_occlusion')) {\n        params.set('disable_occlusion', 'true');\n      }\n      if (this.arScale === 'fixed') {\n        params.set('resizable', 'false');\n      }\n      if (this.arPlacement === 'wall') {\n        params.set('enable_vertical_placement', 'true');\n      }\n      if (params.has('sound')) {\n        const soundUrl = new URL(params.get('sound'), location);\n        params.set('sound', soundUrl.toString());\n      }\n      if (params.has('link')) {\n        const linkUrl = new URL(params.get('link'), location);\n        params.set('link', linkUrl.toString());\n      }\n      const intent = `intent://arvr.google.com/scene-viewer/1.0?${params.toString() + '&file=' + encodeURIComponent(modelUrl.toString())}#Intent;scheme=https;package=com.google.ar.core;action=android.intent.action.VIEW;S.browser_fallback_url=${encodeURIComponent(locationUrl.toString())};end;`;\n      const undoHashChange = () => {\n        if (self.location.hash === noArViewerSigil) {\n          isSceneViewerBlocked = true;\n          // The new history will be the current URL with a new hash.\n          // Go back one step so that we reset to the expected URL.\n          // NOTE(cdata): this should not invoke any browser-level navigation\n          // because hash-only changes modify the URL in-place without\n          // navigating:\n          self.history.back();\n          console.warn('Error while trying to present in AR with Scene Viewer');\n          console.warn('Falling back to next ar-mode');\n          this[$selectARMode]();\n          // Would be nice to activateAR() here, but webXR fails due to not\n          // seeing a user activation.\n        }\n      };\n\n      self.addEventListener('hashchange', undoHashChange, {\n        once: true\n      });\n      this[$arAnchor].setAttribute('href', intent);\n      console.log('Attempting to present in AR with Scene Viewer...');\n      this[$arAnchor].click();\n    }\n    /**\n     * Takes a URL to a USDZ file and sets the appropriate fields so that\n     * Safari iOS can intent to their AR Quick Look.\n     */\n    [$openIOSARQuickLook]() {\n      var _this5 = this;\n      return _asyncToGenerator(function* () {\n        const generateUsdz = !_this5.iosSrc;\n        _this5[$arButtonContainer].classList.remove('enabled');\n        const objectURL = generateUsdz ? yield _this5.prepareUSDZ() : _this5.iosSrc;\n        const modelUrl = new URL(objectURL, self.location.toString());\n        if (generateUsdz) {\n          const location = self.location.toString();\n          const locationUrl = new URL(location);\n          const srcUrl = new URL(_this5.src, locationUrl);\n          if (srcUrl.hash) {\n            modelUrl.hash = srcUrl.hash;\n          }\n        }\n        if (_this5.arScale === 'fixed') {\n          if (modelUrl.hash) {\n            modelUrl.hash += '&';\n          }\n          modelUrl.hash += 'allowsContentScaling=0';\n        }\n        const anchor = _this5[$arAnchor];\n        anchor.setAttribute('rel', 'ar');\n        const img = document.createElement('img');\n        anchor.appendChild(img);\n        anchor.setAttribute('href', modelUrl.toString());\n        if (generateUsdz) {\n          anchor.setAttribute('download', 'model.usdz');\n        }\n        // attach anchor to shadow DOM to ensure iOS16 ARQL banner click message event propagation \n        anchor.style.display = 'none';\n        if (!anchor.isConnected) _this5.shadowRoot.appendChild(anchor);\n        console.log('Attempting to present in AR with Quick Look...');\n        anchor.click();\n        anchor.removeChild(img);\n        if (generateUsdz) {\n          URL.revokeObjectURL(objectURL);\n        }\n        _this5[$arButtonContainer].classList.add('enabled');\n      })();\n    }\n    prepareUSDZ() {\n      var _this6 = this;\n      return _asyncToGenerator(function* () {\n        const updateSourceProgress = _this6[$progressTracker].beginActivity();\n        yield _this6[$triggerLoad]();\n        const {\n          model,\n          shadow\n        } = _this6[$scene];\n        if (model == null) {\n          return '';\n        }\n        let visible = false;\n        // Remove shadow from export\n        if (shadow != null) {\n          visible = shadow.visible;\n          shadow.visible = false;\n        }\n        updateSourceProgress(0.2);\n        const exporter = new USDZExporter();\n        const arraybuffer = yield exporter.parse(model);\n        const blob = new Blob([arraybuffer], {\n          type: 'model/vnd.usdz+zip'\n        });\n        const url = URL.createObjectURL(blob);\n        updateSourceProgress(1);\n        if (shadow != null) {\n          shadow.visible = visible;\n        }\n        return url;\n      })();\n    }\n  }\n  __decorate([property({\n    type: Boolean,\n    attribute: 'ar'\n  })], ARModelViewerElement.prototype, \"ar\", void 0);\n  __decorate([property({\n    type: String,\n    attribute: 'ar-scale'\n  })], ARModelViewerElement.prototype, \"arScale\", void 0);\n  __decorate([property({\n    type: String,\n    attribute: 'ar-placement'\n  })], ARModelViewerElement.prototype, \"arPlacement\", void 0);\n  __decorate([property({\n    type: String,\n    attribute: 'ar-modes'\n  })], ARModelViewerElement.prototype, \"arModes\", void 0);\n  __decorate([property({\n    type: String,\n    attribute: 'ios-src'\n  })], ARModelViewerElement.prototype, \"iosSrc\", void 0);\n  __decorate([property({\n    type: Boolean,\n    attribute: 'xr-environment'\n  })], ARModelViewerElement.prototype, \"xrEnvironment\", void 0);\n  return ARModelViewerElement;\n};\n//# sourceMappingURL=ar.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}